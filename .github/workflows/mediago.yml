name: mediago build
on:
  workflow_dispatch:
    inputs:
      build_type:
        description: 'Build type (e.g., latest, v1.2.0)'
        required: true
        default: 'latest'
  schedule:
    - cron: '0 0 * * *'  # 每天的00:00触发 (此时 build_type 为空)
  push:
    branches:
      - push-all

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/mediago
      CODE_GITHUB: "caorushizi/mediago"
      CODE_PATH: "app"
      LATEST_TAG: "" # 初始化最新的tag变量

    steps:
      - name: Checkout code based on build_type
        run: |
          BUILD_TYPE="${{ github.event.inputs.build_type }}"
          # 对于 schedule 或 push 触发，build_type 为空，视为 latest
          if [[ -z "$BUILD_TYPE" || "$BUILD_TYPE" == "latest" ]]; then
            echo "Build type is 'latest'. Checking out the latest code from main branch."
            git clone https://github.com/${{ env.CODE_GITHUB }}.git ${{ env.CODE_PATH }}
            
            # 获取最新的 release tag
            LATEST_RELEASE_TAG=$(curl -s https://api.github.com/repos/${{ env.CODE_GITHUB }}/releases/latest | jq -r '.tag_name')
            echo "Latest release tag is: $LATEST_RELEASE_TAG"
            echo "LATEST_TAG=${LATEST_RELEASE_TAG}" >> $GITHUB_ENV
          else
            echo "Build type is specific: $BUILD_TYPE. Checking out tag: $BUILD_TYPE"
            git clone -b $BUILD_TYPE https://github.com/${{ env.CODE_GITHUB }}.git ${{ env.CODE_PATH }}
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and Push Docker image
        id: docker_build
        run: |
          # --- 开始：检查 Dockerfile 并确定构建目录 ---
          BUILD_CONTEXT="${{ env.CODE_PATH }}" # 默认构建目录

          # 检查默认目录下是否存在 Dockerfile
          if [ ! -f "$BUILD_CONTEXT/Dockerfile" ]; then
            echo "Dockerfile not found in $BUILD_CONTEXT."
            # 如果不存在，检查是否存在一个名为 'docker' 的子目录，并且该子目录里有 Dockerfile
            if [ -d "$BUILD_CONTEXT/docker" ] && [ -f "$BUILD_CONTEXT/docker/Dockerfile" ]; then
              echo "Found Dockerfile in '$BUILD_CONTEXT/docker'. Setting it as the new build context."
              # 更新构建目录为子目录
              BUILD_CONTEXT="$BUILD_CONTEXT/docker"
            else
              # 如果在两个位置都找不到 Dockerfile，则构建失败
              echo "Error: Dockerfile not found in $BUILD_CONTEXT or $BUILD_CONTEXT/docker."
              exit 1
            fi
          else
            echo "Dockerfile found in $BUILD_CONTEXT."
          fi
          
          echo "Final build context directory: $BUILD_CONTEXT"
          cd $BUILD_CONTEXT # 进入最终确定的构建目录
          # --- 结束：检查 Dockerfile 并确定构建目录 ---

          # 以下是您原有的构建和推送逻辑
          BUILD_TYPE="${{ github.event.inputs.build_type }}"
          BUILD_TAGS=""

          if [[ -z "$BUILD_TYPE" || "$BUILD_TYPE" == "latest" ]]; then
            BUILD_TAGS="-t $IMAGE_NAME:latest"
            
            if ! docker manifest inspect $IMAGE_NAME:${{ env.LATEST_TAG }} &> /dev/null; then
              echo "Tag ${{ env.LATEST_TAG }} does not exist on Docker Hub. Adding it to the build."
              BUILD_TAGS="$BUILD_TAGS -t $IMAGE_NAME:${{ env.LATEST_TAG }}"
            else
              echo "Tag ${{ env.LATEST_TAG }} already exists on Docker Hub. Skipping."
            fi
            
          else
            BUILD_TAGS="-t $IMAGE_NAME:$BUILD_TYPE"
          fi
          
          echo "Final build tags: $BUILD_TAGS"
          
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            $BUILD_TAGS \
            . --push

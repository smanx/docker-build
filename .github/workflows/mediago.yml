name: mediago build
on:
  workflow_dispatch:
    inputs:
      build_type:
        description: 'Build type'
        required: true
        default: 'latest'
  schedule:
    - cron: '0 0 * * *'  # 每天的00:00触发
  push:
    branches:
      - push-all

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/mediago
      REPO_URL: ${{ vars.REPO_URL }}        # 新增：仓库URL变量
      REPO_PATH: ${{ vars.REPO_PATH }}      # 新增：仓库本地路径变量
      BUILD_TAG: ""  # 新增：定义 BUILD_TAG 变量
      CODE_GITHUB: "caorushizi/mediago"
      CODE_PATH: "app"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Get tag based on build_type
        id: get_tag
        run: |
          if [[ "${{ github.event.inputs.build_type }}" == "latest" || "${{ github.event.inputs.build_type }}" == "" ]]; then
            # 获取最新的GitHub release tag
            LATEST_GITHUB_TAG=$(curl -s https://api.github.com/repos/${{env.CODE_GITHUB}}/releases/latest | jq -r '.tag_name')
            echo "LATEST_GITHUB_TAG 的值为: $LATEST_GITHUB_TAG"
            echo "BUILD_TAG=$LATEST_GITHUB_TAG" >> $GITHUB_ENV
            echo "BUILD_LATEST_IMAGE=true" >> $GITHUB_OUTPUT # 标记构建latest镜像
          else
            echo "输入的 build_type 的值为: ${{ github.event.inputs.build_type }}"
            echo "BUILD_TAG=${{ github.event.inputs.build_type }}" >> $GITHUB_ENV
            echo "BUILD_LATEST_IMAGE=false" >> $GITHUB_OUTPUT
          fi

      - name: Download and extract code for specified tag
        if: ${{ steps.get_tag.outputs.BUILD_LATEST_IMAGE == 'false' }} # 如果不是构建latest，则根据 BUILD_TAG 下载
        run: |
          git clone -b ${{ env.BUILD_TAG }} --single-branch https://github.com/${{env.CODE_GITHUB}}.git ${{env.CODE_PATH}}

      - name: Download and extract code for latest
        if: ${{ steps.get_tag.outputs.BUILD_LATEST_IMAGE == 'true' }} # 如果是构建latest，则克隆整个仓库以便 pnpm install
        run: |
          git clone https://github.com/${{env.CODE_GITHUB}}.git ${{env.CODE_PATH}}
          cd ${{env.CODE_PATH}}
          git checkout ${{ env.BUILD_TAG }} # 切换到最新的 tag

      # 设置 Docker 构建环境
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1

      # 登录 DockerHub
      - name: Login to DockerHub
        run: echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin

      # 检查 Docker Hub 上的最新 tag 镜像是否存在
      - name: Check if Docker Hub image tag exists
        id: check_tag_existence
        run: |
          if docker manifest inspect $IMAGE_NAME:${{ env.BUILD_TAG }} &> /dev/null; then
            echo "tag_exists=true" >> $GITHUB_OUTPUT
          else
            echo "tag_exists=false" >> $GITHUB_OUTPUT
          fi
      
      # 构建 App
      - name: Build App
        run: |
          cd ${{env.CODE_PATH}}
          npm install -g pnpm
          pnpm install --no-frozen-lockfile
          pnpm run build:web-release

      # 构建并推送 Docker 镜像
      - name: Build and push Docker image
        run: |
          cd ${{env.CODE_PATH}}
          BUILD_TAGS=""

          # 确保每次都推送 latest 标签
          BUILD_TAGS="$BUILD_TAGS -t $IMAGE_NAME:latest"

          # 如果 BUILD_TAG 对应的镜像不存在，则添加该标签
          if [[ "${{ steps.check_tag_existence.outputs.tag_exists }}" == "false" ]]; then
            echo "Docker Hub 上不存在镜像 tag: ${{ env.BUILD_TAG }}，将添加该标签。"
            BUILD_TAGS="$BUILD_TAGS -t $IMAGE_NAME:${{ env.BUILD_TAG }}"
          else
            echo "Docker Hub 上已存在镜像 tag: ${{ env.BUILD_TAG }}，不重复添加该标签。"
          fi

          echo "最终的 Docker 标签参数: $BUILD_TAGS"

          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            $BUILD_TAGS \
            . --push

name: Process Clash Config

on:
  workflow_dispatch:
    inputs:
      config_url:
        description: 'Clash YAML configuration URL'
        required: true
        default: 'https://raw.githubusercontent.com/mahdibland/SSAggregator/master/sub/sub_merge_yaml.yml'

jobs:
  process_config:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.x'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pyyaml requests

    - name: Process and validate config
      id: process_script
      run: |
        import yaml
        import requests
        import sys
        import os
        import subprocess
        import socket
        import re
        from concurrent.futures import ThreadPoolExecutor, as_completed # 新增导入

        input_file = "clash_config_raw.yml"
        output_file = "clash_config_processed.yml"
        target_api_url = "https://cache.smanx.xx.kg/set"

        config_url = os.environ.get('CONFIG_URL')
        if not config_url:
            print("Error: CONFIG_URL environment variable is not set.")
            sys.exit(1)

        def set_github_output(name, value):
            github_output_path = os.environ.get('GITHUB_OUTPUT')
            if github_output_path:
                with open(github_output_path, 'a') as f:
                    f.write(f"{name}={value}\n")
            else:
                print(f"Warning: GITHUB_OUTPUT environment variable not found. Cannot set output for '{name}'.")

        # Function to perform health check (ping + port check)
        # 注意：这个函数现在需要返回代理配置本身和它的健康状态
        def check_proxy_health(proxy):
            proxy_name = proxy.get('name', 'unknown')
            print(f"Checking health for {proxy_name}...")
            
            server_address = proxy.get('server')
            server_port = proxy.get('port')

            if not server_address:
                print(f"  Proxy {proxy_name} has no 'server' address. Skipping health check.")
                return False, proxy

            # --- 步骤1: Ping 检查 ---
            try:
                ip_address = socket.gethostbyname(server_address)
                # print(f"  Resolved {server_address} to {ip_address}") # 多线程并行时减少日志输出
            except socket.gaierror:
                print(f"  Could not resolve server address '{server_address}'. Ping check failed for {proxy_name}.")
                return False, proxy

            try:
                ping_command = ["ping", "-c", "1", "-W", "1", ip_address]
                # print(f"  Running ping: {' '.join(ping_command)}") # 多线程并行时减少日志输出
                result = subprocess.run(
                    ping_command,
                    capture_output=True,
                    text=True,
                    timeout=5
                )

                if result.returncode == 0:
                    # print(f"  Ping to {ip_address} successful for {proxy_name}.") # 多线程并行时减少日志输出
                    time_match = re.search(r'time=(\d+\.\d+)\s?ms', result.stdout)
                    rtt_time = time_match.group(1) if time_match else 'N/A'
                    # print(f"  Ping stats for {proxy_name}: RTT: {rtt_time} ms.") # 多线程并行时减少日志输出
                else:
                    print(f"  Ping to {ip_address} failed for {proxy_name}. Exit code: {result.returncode}")
                    # print(f"  Ping stderr for {proxy_name}: {result.stderr.strip()}")
                    return False, proxy

            except subprocess.TimeoutExpired:
                print(f"  Ping command timed out for {ip_address} ({proxy_name}).")
                return False, proxy
            except FileNotFoundError:
                print(f"  'ping' command not found. Cannot perform ping check for {proxy_name}.")
                return False, proxy
            except Exception as e:
                print(f"  Error during ping check for {ip_address} ({proxy_name}): {e}")
                return False, proxy

            # --- 步骤2: 端口连通性检查 ---
            if server_port:
                try:
                    target_port = int(server_port)
                    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                        s.settimeout(1)
                        # print(f"  Attempting to connect to {ip_address}:{target_port} ({proxy_name})...") # 多线程并行时减少日志输出
                        s.connect((ip_address, target_port))
                        # print(f"  Successfully connected to {ip_address}:{target_port} ({proxy_name}).") # 多线程并行时减少日志输出
                        return True, proxy
                except ValueError:
                    print(f"  Invalid port '{server_port}' for proxy {proxy_name}. Skipping port check.")
                    return False, proxy
                except socket.timeout:
                    print(f"  Connection to {ip_address}:{target_port} timed out for {proxy_name}. Port might be closed or blocked.")
                    return False, proxy
                except Exception as e:
                    print(f"  Error connecting to port {target_port} on {ip_address} ({proxy_name}): {e}")
                    return False, proxy
            else:
                # print(f"  Proxy {proxy_name} has no 'port' information. Skipping port check.") # 多线程并行时减少日志输出
                return True, proxy
            
            return True, proxy


        try:
            print(f"Downloading config from: {config_url}")
            response = requests.get(config_url)
            response.raise_for_status()
            with open(input_file, 'wb') as f:
                f.write(response.content)

            with open(input_file, 'r', encoding='utf-8') as f:
                config = yaml.safe_load(f)

            healthy_proxies = []
            
            if 'proxies' in config and isinstance(config['proxies'], list):
                proxies_to_check = config['proxies']
                
                # --- *** 新增部分：多线程执行健康检查 *** ---
                max_workers = 10 # 根据需要调整并发线程数
                print(f"Starting health checks with {max_workers} threads for {len(proxies_to_check)} proxies...")
                with ThreadPoolExecutor(max_workers=max_workers) as executor:
                    # 提交所有代理到线程池，并存储 Future 对象
                    future_to_proxy = {executor.submit(check_proxy_health, proxy): proxy for proxy in proxies_to_check}
                    
                    for future in as_completed(future_to_proxy):
                        is_healthy, proxy_checked = future.result()
                        proxy_name = proxy_checked.get('name', 'unknown')
                        if is_healthy:
                            healthy_proxies.append(proxy_checked)
                            print(f"  Proxy {proxy_name} is healthy.")
                        else:
                            print(f"  Excluding unhealthy proxy: {proxy_name}")
                # --- *** 多线程执行结束 *** ---
                
            else:
                print("No 'proxies' section or 'proxies' is not a list found in the input YAML.")

            final_yaml_content = ""
            if healthy_proxies:
                config['proxies'] = healthy_proxies
                with open(output_file, 'w', encoding='utf-8') as f:
                    yaml.dump(config, f, allow_unicode=True, default_flow_style=False, sort_keys=False)
                print(f"Processed configuration saved to {output_file}")
                
                with open(output_file, 'r', encoding='utf-8') as f:
                    final_yaml_content = f.read()
                
                set_github_output("config_generated", "true")
            else:
                print("No healthy proxies found or generated. Skipping output.")
                set_github_output("config_generated", "false")

            if final_yaml_content:
                print(f"Attempting to send processed YAML to {target_api_url}...")
                headers = {'Content-Type': 'application/x-www-form-urlencoded'}
                payload = {
                    'key': 'V2RayAggregator',
                    'value': final_yaml_content
                }
                
                try:
                    post_response = requests.post(target_api_url, data=payload, headers=headers, timeout=10)
                    post_response.raise_for_status()
                    print(f"Successfully posted data to {target_api_url}.")
                    print(f"API Response Status: {post_response.status_code}")
                    print(f"API Response Body: {post_response.text}")
                    set_github_output("api_sent_success", "true")
                except requests.exceptions.RequestException as e:
                    print(f"Error sending data to API {target_api_url}: {e}")
                    set_github_output("api_sent_success", "false")
                except Exception as e:
                    print(f"An unexpected error occurred during API call: {e}")
                    set_github_output("api_sent_success", "false")
            else:
                print("No final YAML content to send to API.")
                set_github_output("api_sent_success", "false")

        except FileNotFoundError:
            print(f"Error: {input_file} not found after download.")
            set_github_output("config_generated", "false")
            set_github_output("api_sent_success", "false")
            sys.exit(1)
        except requests.exceptions.RequestException as e:
            print(f"Error downloading config from {config_url}: {e}")
            set_github_output("config_generated", "false")
            set_github_output("api_sent_success", "false")
            sys.exit(1)
        except yaml.YAMLError as e:
            print(f"Error parsing YAML: {e}")
            set_github_output("config_generated", "false")
            set_github_output("api_sent_success", "false")
            sys.exit(1)
        except Exception as e:
            print(f"An unexpected error occurred: {e}")
            set_github_output("config_generated", "false")
            set_github_output("api_sent_success", "false")
            sys.exit(1)
      env:
        CONFIG_URL: ${{ github.event.inputs.config_url }}
      shell: python

    - name: Upload processed config as artifact
      uses: actions/upload-artifact@v4
      if: success() && steps.process_script.outputs.config_generated == 'true'
      with:
        name: clash-config-clean
        path: clash_config_processed.yml

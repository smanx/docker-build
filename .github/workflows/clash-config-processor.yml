name: Process Clash Config

on:
  workflow_dispatch:
    inputs:
      config_url:
        description: 'Clash YAML configuration URL'
        required: true
        default: 'https://raw.githubusercontent.com/mahdibland/SSAggregator/master/sub/sub_merge_yaml.yml'

jobs:
  process_config:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.x'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pyyaml requests

    - name: Process and validate config
      id: process_script
      run: |
        import yaml
        import requests
        import sys
        import os
        import subprocess
        import socket
        import re

        input_file = "clash_config_raw.yml"
        output_file = "clash_config_processed.yml"
        # 定义目标API接口
        target_api_url = "https://cache.smanx.xx.kg/set"

        # Get the config URL from environment variable passed by GitHub Actions
        config_url = os.environ.get('CONFIG_URL')
        if not config_url:
            print("Error: CONFIG_URL environment variable is not set.")
            sys.exit(1)

        # Function to set GitHub Action output variables (updated for GITHUB_OUTPUT)
        def set_github_output(name, value):
            github_output_path = os.environ.get('GITHUB_OUTPUT')
            if github_output_path:
                with open(github_output_path, 'a') as f:
                    f.write(f"{name}={value}\n")
            else:
                print(f"Warning: GITHUB_OUTPUT environment variable not found. Cannot set output for '{name}'.")

        # Function to perform health check (ping + port check)
        def check_proxy_health(proxy_name, proxy_config):
            print(f"Checking health for {proxy_name}...")
            
            server_address = proxy_config.get('server')
            server_port = proxy_config.get('port')

            if not server_address:
                print(f"  Proxy {proxy_name} has no 'server' address. Skipping health check.")
                return False

            # --- 步骤1: Ping 检查 ---
            try:
                ip_address = socket.gethostbyname(server_address)
                print(f"  Resolved {server_address} to {ip_address}")
            except socket.gaierror:
                print(f"  Could not resolve server address '{server_address}'. Ping check failed.")
                return False

            try:
                ping_command = ["ping", "-c", "1", "-W", "1", ip_address]
                print(f"  Running ping: {' '.join(ping_command)}")
                result = subprocess.run(
                    ping_command,
                    capture_output=True,
                    text=True,
                    timeout=5
                )

                if result.returncode == 0:
                    print(f"  Ping to {ip_address} successful.")
                    time_match = re.search(r'time=(\d+\.\d+)\s?ms', result.stdout)
                    rtt_time = time_match.group(1) if time_match else 'N/A'
                    print(f"  Ping stats: RTT: {rtt_time} ms.")
                else:
                    print(f"  Ping to {ip_address} failed. Exit code: {result.returncode}")
                    print(f"  Ping stderr: {result.stderr.strip()}")
                    return False

            except subprocess.TimeoutExpired:
                print(f"  Ping command timed out for {ip_address}.")
                return False
            except FileNotFoundError:
                print(f"  'ping' command not found. Cannot perform ping check.")
                return False
            except Exception as e:
                print(f"  Error during ping check for {ip_address}: {e}")
                return False

            # --- 步骤2: 端口连通性检查 ---
            if server_port:
                try:
                    target_port = int(server_port)
                    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                        s.settimeout(1)
                        print(f"  Attempting to connect to {ip_address}:{target_port}...")
                        s.connect((ip_address, target_port))
                        print(f"  Successfully connected to {ip_address}:{target_port}.")
                        return True
                except ValueError:
                    print(f"  Invalid port '{server_port}' for proxy {proxy_name}. Skipping port check.")
                    return False
                except socket.timeout:
                    print(f"  Connection to {ip_address}:{target_port} timed out. Port might be closed or blocked.")
                    return False
                except Exception as e:
                    print(f"  Error connecting to port {target_port} on {ip_address}: {e}")
                    return False
            else:
                print(f"  Proxy {proxy_name} has no 'port' information. Skipping port check.")
                return True
            
            return True


        try:
            # Download the config file
            print(f"Downloading config from: {config_url}")
            response = requests.get(config_url)
            response.raise_for_status()
            with open(input_file, 'wb') as f:
                f.write(response.content)

            with open(input_file, 'r', encoding='utf-8') as f:
                config = yaml.safe_load(f)

            healthy_proxies = []
            if 'proxies' in config and isinstance(config['proxies'], list):
                for proxy in config['proxies']:
                    proxy_name = proxy.get('name', 'unknown')
                    if check_proxy_health(proxy_name, proxy):
                        healthy_proxies.append(proxy)
                    else:
                        print(f"Excluding unhealthy proxy: {proxy_name}")
            else:
                print("No 'proxies' section or 'proxies' is not a list found in the input YAML.")

            final_yaml_content = ""
            if healthy_proxies:
                config['proxies'] = healthy_proxies
                with open(output_file, 'w', encoding='utf-8') as f:
                    yaml.dump(config, f, allow_unicode=True, default_flow_style=False, sort_keys=False)
                print(f"Processed configuration saved to {output_file}")
                
                # 读取最终处理后的YAML文件内容
                with open(output_file, 'r', encoding='utf-8') as f:
                    final_yaml_content = f.read()
                
                set_github_output("config_generated", "true")
            else:
                print("No healthy proxies found or generated. Skipping output.")
                set_github_output("config_generated", "false")

            # --- *** 新增部分：将数据发送到API接口 *** ---
            if final_yaml_content: # 只有当有内容生成时才发送
                print(f"Attempting to send processed YAML to {target_api_url}...")
                headers = {'Content-Type': 'application/x-www-form-urlencoded'}
                # 注意：这里的数据是 'application/x-www-form-urlencoded' 格式
                # key=V2RayAggregator&value=<yaml_content>
                payload = {
                    'key': 'V2RayAggregator',
                    'value': final_yaml_content
                }
                
                try:
                    # 使用 requests.post 发送 POST 请求
                    post_response = requests.post(target_api_url, data=payload, headers=headers, timeout=10)
                    post_response.raise_for_status() # 对HTTP错误抛出异常
                    print(f"Successfully posted data to {target_api_url}.")
                    print(f"API Response Status: {post_response.status_code}")
                    print(f"API Response Body: {post_response.text}")
                    set_github_output("api_sent_success", "true")
                except requests.exceptions.RequestException as e:
                    print(f"Error sending data to API {target_api_url}: {e}")
                    set_github_output("api_sent_success", "false")
                except Exception as e:
                    print(f"An unexpected error occurred during API call: {e}")
                    set_github_output("api_sent_success", "false")
            else:
                print("No final YAML content to send to API.")
                set_github_output("api_sent_success", "false")
            # --- *** 新增部分结束 *** ---

        except FileNotFoundError:
            print(f"Error: {input_file} not found after download.")
            set_github_output("config_generated", "false")
            set_github_output("api_sent_success", "false")
            sys.exit(1)
        except requests.exceptions.RequestException as e:
            print(f"Error downloading config from {config_url}: {e}")
            set_github_output("config_generated", "false")
            set_github_output("api_sent_success", "false")
            sys.exit(1)
        except yaml.YAMLError as e:
            print(f"Error parsing YAML: {e}")
            set_github_output("config_generated", "false")
            set_github_output("api_sent_success", "false")
            sys.exit(1)
        except Exception as e:
            print(f"An unexpected error occurred: {e}")
            set_github_output("config_generated", "false")
            set_github_output("api_sent_success", "false")
            sys.exit(1)
      env:
        CONFIG_URL: ${{ github.event.inputs.config_url }}
      shell: python

    - name: Upload processed config as artifact
      uses: actions/upload-artifact@v4
      if: success() && steps.process_script.outputs.config_generated == 'true'
      with:
        name: clash-config-clean
        path: clash_config_processed.yml

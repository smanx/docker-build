name: Process Clash Config (Node.js)

on:
  workflow_dispatch:
    inputs:
      config_url:
        description: 'Clash YAML configuration URL'
        required: true
        default: 'https://raw.githubusercontent.com/mahdibland/SSAggregator/master/sub/sub_merge_yaml.yml'

jobs:
  process_config:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4 # Changed to Node.js setup
      with:
        node-version: '18.x' # Or a recent LTS version

    - name: Install dependencies
      run: |
        npm install yaml axios # Install yaml and axios modules

    - name: Process and validate config
      id: process_script
      run: |
        const fs = require('fs/promises'); // For file system operations (async)
        const path = require('path');
        const yaml = require('yaml');
        const axios = require('axios');
        const { exec } = require('child_process'); // For ping command
        const net = require('net'); // For TCP port check
        const dns = require('dns/promises'); // For async DNS lookup

        const inputFileName = "clash_config_raw.yml";
        const outputFileName = "clash_config_processed.yml";
        const targetApiUrl = "https://cache.smanx.xx.kg/set";

        const configUrl = process.env.CONFIG_URL;

        if (!configUrl) {
          console.error("Error: CONFIG_URL environment variable is not set.");
          process.exit(1);
        }

        // Function to set GitHub Action output variables
        function setGitHubOutput(name, value) {
          const githubOutputPath = process.env.GITHUB_OUTPUT;
          if (githubOutputPath) {
            fs.appendFileSync(githubOutputPath, `${name}=${value}\n`);
          } else {
            console.warn(`Warning: GITHUB_OUTPUT environment variable not found. Cannot set output for '${name}'.`);
          }
        }

        // Function to perform health check (ping + port check)
        async function checkProxyHealth(proxyName, proxyConfig) {
          console.log(`Checking health for ${proxyName}...`);

          const serverAddress = proxyConfig.server;
          const serverPort = proxyConfig.port;

          if (!serverAddress) {
            console.log(`  Proxy ${proxyName} has no 'server' address. Skipping health check.`);
            return false;
          }

          let ipAddress;
          try {
            const addresses = await dns.lookup(serverAddress);
            ipAddress = addresses.address;
            console.log(`  Resolved ${serverAddress} to ${ipAddress}`);
          } catch (error) {
            console.log(`  Could not resolve server address '${serverAddress}'. Ping check failed.`);
            return false;
          }

          // --- Step 1: Ping Check ---
          try {
            // Using `exec` for simpler command execution, but `spawn` could be used for more fine-grained control
            const pingCommand = `ping -c 1 -W 1 ${ipAddress}`;
            console.log(`  Running ping: ${pingCommand}`);

            const { stdout, stderr } = await new Promise((resolve, reject) => {
              exec(pingCommand, { timeout: 5000 }, (error, stdout, stderr) => { // 5 second timeout for the entire ping command
                if (error) {
                  reject(error);
                } else {
                  resolve({ stdout, stderr });
                }
              });
            });

            if (stderr) {
              console.log(`  Ping to ${ipAddress} failed. Stderr: ${stderr.trim()}`);
              return false;
            }

            // Check stdout for success message for Linux ping (different from Windows)
            // Example: "1 packets transmitted, 1 received, 0% packet loss, time 0ms"
            const successMatch = stdout.match(/1 received/);
            if (successMatch) {
              console.log(`  Ping to ${ipAddress} successful.`);
              const timeMatch = stdout.match(/time=(\d+\.\d+)\s?ms/);
              const rttTime = timeMatch ? timeMatch[1] : 'N/A';
              console.log(`  Ping stats: RTT: ${rttTime} ms.`);
            } else {
              console.log(`  Ping to ${ipAddress} failed. Stdout: ${stdout.trim()}`);
              return false;
            }

          } catch (error) {
            if (error.code === 'ETIMEDOUT' || error.killed && error.signal === 'SIGTERM') {
              console.log(`  Ping command timed out for ${ipAddress}.`);
            } else if (error.code === 'ENOENT') {
              console.log(`  'ping' command not found. Cannot perform ping check.`);
            } else {
              console.log(`  Error during ping check for ${ipAddress}: ${error.message}`);
            }
            return false;
          }

          // --- Step 2: Port Connectivity Check ---
          if (serverPort) {
            try {
              const targetPort = parseInt(serverPort, 10);
              if (isNaN(targetPort)) {
                console.log(`  Invalid port '${serverPort}' for proxy ${proxyName}. Skipping port check.`);
                return false;
              }

              return await new Promise((resolve) => {
                const client = new net.Socket();
                client.setTimeout(1000); // 1 second timeout for connection

                client.once('connect', () => {
                  console.log(`  Successfully connected to ${ipAddress}:${targetPort}.`);
                  client.end();
                  resolve(true);
                });

                client.once('timeout', () => {
                  console.log(`  Connection to ${ipAddress}:${targetPort} timed out. Port might be closed or blocked.`);
                  client.destroy();
                  resolve(false);
                });

                client.once('error', (err) => {
                  console.log(`  Error connecting to port ${targetPort} on ${ipAddress}: ${err.message}`);
                  client.destroy();
                  resolve(false);
                });

                client.connect(targetPort, ipAddress);
              });

            } catch (error) {
              console.log(`  Error during port check for ${ipAddress}:${serverPort}: ${error.message}`);
              return false;
            }
          } else {
            console.log(`  Proxy ${proxyName} has no 'port' information. Skipping port check.`);
            return true; // If no port info and ping successful, consider it healthy
          }
        }

        async function main() {
          let configGenerated = 'false';
          let apiSentSuccess = 'false';

          try {
            // Download the config file
            console.log(`Downloading config from: ${configUrl}`);
            const response = await axios.get(configUrl);
            await fs.writeFile(inputFileName, response.data);
            console.log(`Downloaded config to ${inputFileName}`);

            const rawConfigContent = await fs.readFile(inputFileName, 'utf-8');
            const config = yaml.parse(rawConfigContent);

            const healthyProxies = [];
            if (config.proxies && Array.isArray(config.proxies)) {
              for (const proxy of config.proxies) {
                const proxyName = proxy.name || 'unknown';
                const isHealthy = await checkProxyHealth(proxyName, proxy);
                if (isHealthy) {
                  healthyProxies.push(proxy);
                } else {
                  console.log(`Excluding unhealthy proxy: ${proxyName}`);
                }
              }
            } else {
              console.log("No 'proxies' section or 'proxies' is not a list found in the input YAML.");
            }

            let finalYamlContent = "";
            if (healthyProxies.length > 0) {
              config.proxies = healthyProxies;
              finalYamlContent = yaml.stringify(config);
              await fs.writeFile(outputFileName, finalYamlContent, 'utf-8');
              console.log(`Processed configuration saved to ${outputFileName}`);
              configGenerated = 'true';
            } else {
              console.log("No healthy proxies found or generated. Skipping output.");
            }

            // --- Send data to API interface ---
            if (finalYamlContent) {
              console.log(`Attempting to send processed YAML to ${targetApiUrl}...`);
              const headers = {'Content-Type': 'application/x-www-form-urlencoded'};
              const payload = new URLSearchParams({
                key: 'V2RayAggregator',
                value: finalYamlContent
              }).toString(); // URLSearchParams to properly encode for application/x-www-form-urlencoded

              try {
                const postResponse = await axios.post(targetApiUrl, payload, { headers, timeout: 10000 }); // 10 second timeout
                console.log(`Successfully posted data to ${targetApiUrl}.`);
                console.log(`API Response Status: ${postResponse.status}`);
                console.log(`API Response Body: ${postResponse.data}`);
                apiSentSuccess = 'true';
              } catch (error) {
                console.error(`Error sending data to API ${targetApiUrl}: ${error.message}`);
                if (error.response) {
                  console.error(`API Error Response Status: ${error.response.status}`);
                  console.error(`API Error Response Body: ${error.response.data}`);
                }
              }
            } else {
              console.log("No final YAML content to send to API.");
            }

          } catch (error) {
            console.error(`An error occurred during config processing: ${error.stack}`);
            process.exit(1); // Exit with a non-zero code to indicate failure
          } finally {
            setGitHubOutput("config_generated", configGenerated);
            setGitHubOutput("api_sent_success", apiSentSuccess);
          }
        }

        main();
        
      env:
        CONFIG_URL: ${{ github.event.inputs.config_url }}
      shell: node {0} # Use node as the shell interpreter

    - name: Upload processed config as artifact
      uses: actions/upload-artifact@v4
      if: success() && steps.process_script.outputs.config_generated == 'true'
      with:
        name: clash-config-clean
        path: clash_config_processed.yml

name: Process Clash Config

on:
  workflow_dispatch:
    inputs:
      config_url:
        description: 'Clash YAML configuration URL'
        required: true
        default: 'https://raw.githubusercontent.com/mahdibland/SSAggregator/master/sub/sub_merge_yaml.yml'

jobs:
  process_config:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.x'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pyyaml requests
        # --- 新增：安装 fping ---
        sudo apt-get update
        sudo apt-get install -y fping

    - name: Process and validate config
      id: process_script
      run: |
        import yaml
        import requests
        import sys
        import os
        import subprocess
        import socket
        import re
        from concurrent.futures import ThreadPoolExecutor, as_completed
        import threading

        print_lock = threading.Lock() 

        input_file = "clash_config_raw.yml"
        output_file = "clash_config_processed.yml"
        target_api_url = "https://cache.smanx.xx.kg/set"

        config_url = os.environ.get('CONFIG_URL')
        if not config_url:
            print("Error: CONFIG_URL environment variable is not set.")
            sys.exit(1)

        def set_github_output(name, value):
            github_output_path = os.environ.get('GITHUB_OUTPUT')
            if github_output_path:
                with open(github_output_path, 'a') as f:
                    f.write(f"{name}={value}\n")
            else:
                print(f"Warning: GITHUB_OUTPUT environment variable not found. Cannot set output for '{name}'.")

        def check_proxy_health(proxy):
            thread_id = threading.current_thread().name
            proxy_name = proxy.get('name', 'unknown')
            
            with print_lock:
                print(f"[{thread_id}] Checking health for {proxy_name}...")
            
            server_address = proxy.get('server')
            server_port = proxy.get('port')

            if not server_address:
                with print_lock:
                    print(f"[{thread_id}]   Proxy {proxy_name} has no 'server' address. Skipping health check.")
                return False, proxy

            ip_address = None
            try:
                ip_address = socket.gethostbyname(server_address)
            except socket.gaierror:
                with print_lock:
                    print(f"[{thread_id}]   Could not resolve server address '{server_address}'. Ping check failed for {proxy_name}.")
                return False, proxy

            # --- 步骤1: fping 检查 ---
            ping_successful = False
            rtt_time = "N/A"
            try:
                # 使用 fping 命令
                # -c 1: 发送1个包
                # -t 500: 超时500毫秒 (0.5秒)
                # -q: 静默输出，只显示结果摘要
                fping_command = ["/usr/bin/fping", "-c", "1", "-t", "500", "-q", ip_address] 
                result = subprocess.run(
                    fping_command,
                    capture_output=True,
                    text=True,
                    timeout=5 # 整个fping命令的超时时间
                )

                # fping 的返回码：0表示所有目标可达，1表示部分可达，2表示全部不可达
                if result.returncode == 0:
                    ping_successful = True
                    # fping的输出格式可能不同，这里假设我们需要解析类似于 "target : x.xx ms" 的RTT
                    # 由于-q参数，stdout可能是空的，但如果成功，也就不需要解析了
                    # 如果需要更精确的RTT，可以去掉-q，然后解析stdout
                    # 简化处理：只要返回0就认为是成功
                    with print_lock:
                        print(f"[{thread_id}]   Fping to {ip_address} successful for {proxy_name}.")
                else:
                    with print_lock:
                        print(f"[{thread_id}]   Fping to {ip_address} failed for {proxy_name}. Exit code: {result.returncode}.")
                        if result.stderr:
                            print(f"[{thread_id}]     Fping stderr: {result.stderr.strip()}")
                        if result.stdout:
                            print(f"[{thread_id}]     Fping stdout: {result.stdout.strip()}")
                    return False, proxy

            except subprocess.TimeoutExpired:
                with print_lock:
                    print(f"[{thread_id}]   Fping command timed out for {ip_address} ({proxy_name}).")
                return False, proxy
            except FileNotFoundError:
                with print_lock:
                    print(f"[{thread_id}]   '/usr/bin/fping' command not found. Cannot perform ping check for {proxy_name}.")
                return False, proxy
            except Exception as e:
                with print_lock:
                    print(f"[{thread_id}]   Error during fping check for {ip_address} ({proxy_name}): {e}")
                return False, proxy

            # --- 步骤2: 端口连通性检查 --- (这部分保持不变)
            if server_port:
                try:
                    target_port = int(server_port)
                    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                        s.settimeout(1)
                        s.connect((ip_address, target_port))
                        with print_lock:
                            print(f"[{thread_id}]   Successfully connected to {ip_address}:{target_port} for {proxy_name}.")
                        return True, proxy
                except ValueError:
                    with print_lock:
                        print(f"[{thread_id}]   Invalid port '{server_port}' for proxy {proxy_name}. Skipping port check.")
                    return False, proxy
                except socket.timeout:
                    with print_lock:
                        print(f"[{thread_id}]   Connection to {ip_address}:{target_port} timed out for {proxy_name}. Port might be closed or blocked.")
                    return False, proxy
                except Exception as e:
                    with print_lock:
                        print(f"[{thread_id}]   Error connecting to port {target_port} on {ip_address} ({proxy_name}): {e}")
                    return False, proxy
            elif ping_successful:
                with print_lock:
                    print(f"[{thread_id}]   Proxy {proxy_name} has no 'port' information. Ping was successful.")
                return True, proxy
            
            with print_lock:
                print(f"[{thread_id}]   Proxy {proxy_name} failed all checks.")
            return False, proxy


        # ... (以下部分保持不变，与方案一相同)

name: Process Clash Config

on:
  workflow_dispatch:
    inputs:
      config_url:
        description: 'Clash YAML configuration URL'
        required: true
        default: 'https://raw.githubusercontent.com/mahdibland/SSAggregator/master/sub/sub_merge_yaml.yml'

jobs:
  process_config:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.x'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pyyaml requests

    - name: Process and validate config
      id: process_script
      run: |
        import yaml
        import requests
        import sys
        import os
        import subprocess
        import socket
        import re
        from concurrent.futures import ThreadPoolExecutor, as_completed
        import threading

        # 定义一个简单的线程锁，用于控制打印，防止输出混乱
        print_lock = threading.Lock() 

        input_file = "clash_config_raw.yml"
        output_file = "clash_config_processed.yml"
        target_api_url = "https://cache.smanx.xx.kg/set"

        config_url = os.environ.get('CONFIG_URL')
        if not config_url:
            print("Error: CONFIG_URL environment variable is not set.")
            sys.exit(1)

        def set_github_output(name, value):
            github_output_path = os.environ.get('GITHUB_OUTPUT')
            if github_output_path:
                with open(github_output_path, 'a') as f:
                    f.write(f"{name}={value}\n")
            else:
                print(f"Warning: GITHUB_OUTPUT environment variable not found. Cannot set output for '{name}'.")

        # Function to perform health check (ping + port check)
        def check_proxy_health(proxy):
            thread_id = threading.current_thread().name
            proxy_name = proxy.get('name', 'unknown')
            
            with print_lock:
                print(f"[{thread_id}] Checking health for {proxy_name}...")
            
            server_address = proxy.get('server')
            server_port = proxy.get('port')

            if not server_address:
                with print_lock:
                    print(f"[{thread_id}]   Proxy {proxy_name} has no 'server' address. Skipping health check.")
                return False, proxy

            ip_address = None
            try:
                ip_address = socket.gethostbyname(server_address)
            except socket.gaierror:
                with print_lock:
                    print(f"[{thread_id}]   Could not resolve server address '{server_address}'. Ping check failed for {proxy_name}.")
                return False, proxy

            # --- 步骤1: Ping 检查 ---
            ping_successful = False
            rtt_time = "N/A"
            try:
                # 明确指定ping命令路径，并使用更通用的参数
                # -c 1: 发送1个包
                # -W 1: 等待1秒超时
                # -q: 静默输出，只显示摘要 (这不会影响捕获输出)
                # sudo setcap cap_net_raw+ep /bin/ping 如果在非root用户下，可能需要此权限。
                # 在GitHub Actions的ubuntu-latest环境中，ping通常应该可用。
                ping_command = ["/bin/ping", "-c", "1", "-W", "1", ip_address] 
                result = subprocess.run(
                    ping_command,
                    capture_output=True,
                    text=True,
                    timeout=5 # 整个ping命令的超时时间
                )

                if result.returncode == 0:
                    ping_successful = True
                    time_match = re.search(r'time=(\d+\.\d+)\s?ms', result.stdout)
                    rtt_time = time_match.group(1) if time_match else 'N/A'
                    with print_lock:
                        print(f"[{thread_id}]   Ping to {ip_address} successful for {proxy_name}. RTT: {rtt_time} ms.")
                else:
                    with print_lock:
                        print(f"[{thread_id}]   Ping to {ip_address} failed for {proxy_name}. Exit code: {result.returncode}.")
                        # 打印ping命令的stderr和stdout以便诊断
                        if result.stderr:
                            print(f"[{thread_id}]     Ping stderr: {result.stderr.strip()}")
                        if result.stdout:
                            print(f"[{thread_id}]     Ping stdout: {result.stdout.strip()}")
                    return False, proxy

            except subprocess.TimeoutExpired:
                with print_lock:
                    print(f"[{thread_id}]   Ping command timed out for {ip_address} ({proxy_name}).")
                return False, proxy
            except FileNotFoundError:
                with print_lock:
                    print(f"[{thread_id}]   '/bin/ping' command not found. Cannot perform ping check for {proxy_name}.")
                return False, proxy
            except Exception as e:
                with print_lock:
                    print(f"[{thread_id}]   Error during ping check for {ip_address} ({proxy_name}): {e}")
                return False, proxy

            # --- 步骤2: 端口连通性检查 ---
            if server_port:
                try:
                    target_port = int(server_port)
                    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                        s.settimeout(1) # 端口连接超时
                        s.connect((ip_address, target_port))
                        with print_lock:
                            print(f"[{thread_id}]   Successfully connected to {ip_address}:{target_port} for {proxy_name}.")
                        return True, proxy
                except ValueError:
                    with print_lock:
                        print(f"[{thread_id}]   Invalid port '{server_port}' for proxy {proxy_name}. Skipping port check.")
                    return False, proxy
                except socket.timeout:
                    with print_lock:
                        print(f"[{thread_id}]   Connection to {ip_address}:{target_port} timed out for {proxy_name}. Port might be closed or blocked.")
                    return False, proxy
                except Exception as e:
                    with print_lock:
                        print(f"[{thread_id}]   Error connecting to port {target_port} on {ip_address} ({proxy_name}): {e}")
                    return False, proxy
            elif ping_successful:
                with print_lock:
                    print(f"[{thread_id}]   Proxy {proxy_name} has no 'port' information. Ping was successful.")
                return True, proxy
            
            with print_lock:
                print(f"[{thread_id}]   Proxy {proxy_name} failed all checks.")
            return False, proxy


        try:
            print(f"Downloading config from: {config_url}")
            response = requests.get(config_url)
            response.raise_for_status()
            with open(input_file, 'wb') as f:
                f.write(response.content)

            with open(input_file, 'r', encoding='utf-8') as f:
                config = yaml.safe_load(f)

            healthy_proxies = []
            
            if 'proxies' in config and isinstance(config['proxies'], list):
                proxies_to_check = config['proxies']
                
                max_workers = 100
                print(f"Starting health checks with {max_workers} threads for {len(proxies_to_check)} proxies...")
                
                with ThreadPoolExecutor(max_workers=max_workers) as executor:
                    future_to_proxy = {executor.submit(check_proxy_health, proxy): proxy for proxy in proxies_to_check}
                    
                    for future in as_completed(future_to_proxy):
                        try:
                            is_healthy, proxy_checked = future.result()
                            if is_healthy:
                                healthy_proxies.append(proxy_checked)
                        except Exception as exc:
                            proxy_name_of_failed_task = future_to_proxy[future].get('name', 'unknown')
                            with print_lock:
                                print(f"Proxy {proxy_name_of_failed_task} generated an exception: {exc}")
                
            else:
                print("No 'proxies' section or 'proxies' is not a list found in the input YAML.")

            final_yaml_content = ""
            if healthy_proxies:
                config['proxies'] = healthy_proxies
                with open(output_file, 'w', encoding='utf-8') as f:
                    yaml.dump(config, f, allow_unicode=True, default_flow_style=False, sort_keys=False)
                print(f"Processed configuration saved to {output_file}")
                
                with open(output_file, 'r', encoding='utf-8') as f:
                    final_yaml_content = f.read()
                
                set_github_output("config_generated", "true")
            else:
                print("No healthy proxies found or generated. Skipping output.")
                set_github_output("config_generated", "false")

            if final_yaml_content:
                print(f"Attempting to send processed YAML to {target_api_url}...")
                headers = {'Content-Type': 'application/x-www-form-urlencoded'}
                payload = {
                    'key': 'V2RayAggregator',
                    'value': final_yaml_content
                }
                
                try:
                    post_response = requests.post(target_api_url, data=payload, headers=headers, timeout=10)
                    post_response.raise_for_status()
                    print(f"Successfully posted data to {target_api_url}.")
                    print(f"API Response Status: {post_response.status_code}")
                    print(f"API Response Body: {post_response.text}")
                    set_github_output("api_sent_success", "true")
                except requests.exceptions.RequestException as e:
                    print(f"Error sending data to API {target_api_url}: {e}")
                    set_github_output("api_sent_success", "false")
                except Exception as e:
                    print(f"An unexpected error occurred during API call: {e}")
                    set_github_output("api_sent_success", "false")
            else:
                print("No final YAML content to send to API.")
                set_github_output("api_sent_success", "false")

        except FileNotFoundError:
            print(f"Error: {input_file} not found after download.")
            set_github_output("config_generated", "false")
            set_github_output("api_sent_success", "false")
            sys.exit(1)
        except requests.exceptions.RequestException as e:
            print(f"Error downloading config from {config_url}: {e}")
            set_github_output("config_generated", "false")
            set_github_output("api_sent_success", "false")
            sys.exit(1)
        except yaml.YAMLError as e:
            print(f"Error parsing YAML: {e}")
            set_github_output("config_generated", "false")
            set_github_output("api_sent_success", "false")
            sys.exit(1)
        except Exception as e:
            print(f"An unexpected error occurred: {e}")
            set_github_output("config_generated", "false")
            set_github_output("api_sent_success", "false")
            sys.exit(1)
      env:
        CONFIG_URL: ${{ github.event.inputs.config_url }}
      shell: python

    - name: Upload processed config as artifact
      uses: actions/upload-artifact@v4
      if: success() && steps.process_script.outputs.config_generated == 'true'
      with:
        name: clash-config-clean
        path: clash_config_processed.yml
